/*! Auto-generated by xtask-gen. DO NOT EDIT! */

import { invoke } from "@tauri-apps/api/core";
import * as tauriEvent from "@tauri-apps/api/event";

// =============================================================================
// Types
// =============================================================================

/**
 * Deskulpt window enum.
 */
export type DeskulptWindow = 
/**
 * The manager window.
 */
"manager" | 
/**
 * The canvas window.
 */
"canvas"

export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }

/**
 * A result-like binary outcome.
 * 
 * This represents the outcome of an operation that can either succeed with a
 * value of type `T` or fail with an error message.
 */
export type Outcome<T> = { type: "ok"; content: T } | { type: "err"; content: string }

/**
 * Event for rendering widgets.
 * 
 * This event is emitted from the backend to the canvas window to instruct it
 * to render the provided widgets. The event carries a mapping from widget IDs
 * to their corresponding code strings.
 */
export type RenderWidgetsEvent = { [key in string]: Outcome<string> }

/**
 * Full settings of the Deskulpt application.
 */
export type Settings = { 
/**
 * The application theme.
 */
theme: Theme; 
/**
 * The keyboard shortcuts.
 */
shortcuts: Partial<{ [key in ShortcutKey]: string }>; 
/**
 * The mapping from widget IDs to their respective settings.
 */
widgets: { [key in string]: WidgetSettings } }

/**
 * A patch for partial updates to [`Settings`].
 */
export type SettingsPatch = { 
/**
 * If not `None`, update [`Settings::theme`].
 */
theme?: Theme; 
/**
 * If not `None`, update [`Settings::shortcuts`].
 * 
 * Non-specified shortcuts will remain unchanged. If a shortcut value is
 * `None`, it means removing that shortcut. Otherwise, it means updating
 * or adding that shortcut.
 */
shortcuts?: Partial<{ [key in ShortcutKey]: string | null }>; 
/**
 * If not `None`, update [`Settings::widgets`].
 * 
 * Non-specified widgets will remain unchanged. If a widget settings patch
 * is `None`, it means leaving that widget settings unchanged. Otherwise,
 * it means applying the patch to that widget settings. If the widget ID
 * does not exist, a new widget settings will be created with default
 * values, and then the patch will be applied to it.
 */
widgets?: { [key in string]: WidgetSettingsPatch | null } }

/**
 * Types of keyboard shortcuts in the application.
 */
export type ShortcutKey = 
/**
 * For toggling canvas interaction mode.
 */
"toggleCanvasImode" | 
/**
 * For opening the manager window.
 */
"openManager"

/**
 * Event for showing a toast notification.
 * 
 * This event is emitted from the backend to the canvas window when a toast
 * notification needs to be displayed.
 */
export type ShowToastEvent = 
/**
 * Show a [success](https://sonner.emilkowal.ski/toast#success) toast.
 */
{ type: "success"; content: string } | 
/**
 * Show an [error](https://sonner.emilkowal.ski/toast#error) toast.
 */
{ type: "error"; content: string }

/**
 * Light/dark theme of the application.
 */
export type Theme = "light" | "dark"

/**
 * Event for updating the settings.
 * 
 * This event is emitted from the backend to all frontend windows whenever
 * there is a change in the settings. Full settings are included to ensure
 * that all windows see the most up-to-date version eventually.
 */
export type UpdateSettingsEvent = Settings

/**
 * Event for updating the widget catalog.
 * 
 * This event is emitted from the backend to the manager window whenever there
 * is a change in the widget catalog.
 */
export type UpdateWidgetCatalogEvent = WidgetCatalog

/**
 * The widget catalog.
 * 
 * This is a collection of all widgets discovered locally, mapped from their
 * widget IDs to their configurations.
 */
export type WidgetCatalog = { [key in string]: Outcome<WidgetConfig> }

/**
 * Full configuration of a Deskulpt widget.
 */
export type WidgetConfig = { 
/**
 * The name of the widget.
 */
name: string; 
/**
 * The entry point of the widget.
 */
entry: string; 
/**
 * The dependencies of the widget.
 */
dependencies: { [key in string]: string } }

/**
 * Per-widget settings.
 * 
 * Different from widget configurations, these are independent of the widget
 * configuration files and are managed internally by the application.
 */
export type WidgetSettings = { 
/**
 * The leftmost x-coordinate in pixels.
 */
x: number; 
/**
 * The topmost y-coordinate in pixels.
 */
y: number; 
/**
 * The width in pixels.
 */
width: number; 
/**
 * The height in pixels.
 */
height: number; 
/**
 * The opacity in percentage.
 */
opacity: number }

/**
 * A patch for partial updates to [`WidgetSettings`].
 */
export type WidgetSettingsPatch = { 
/**
 * If not `None`, update [`WidgetSettings::x`].
 */
x?: number; 
/**
 * If not `None`, update [`WidgetSettings::y`].
 */
y?: number; 
/**
 * If not `None`, update [`WidgetSettings::width`].
 */
width?: number; 
/**
 * If not `None`, update [`WidgetSettings::height`].
 */
height?: number; 
/**
 * If not `None`, update [`WidgetSettings::opacity`].
 */
opacity?: number }

// =============================================================================
// Events
// =============================================================================

function makeEvent<T>(name: string) {
  return {
    /** Listen for the event. */
    listen: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.listen(name, cb, options),
    /** Listen once for the event. */
    once: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.once(name, cb, options),
    /** Emit the event to all targets. */
    emit: (payload: T) => tauriEvent.emit(name, payload),
    /** Emit the event to a specific Deskulpt window. */
    emitTo: (window: DeskulptWindow, payload: T) =>
      tauriEvent.emitTo(window, name, payload),
  };
}

export const events = {
  renderWidgets: makeEvent<RenderWidgetsEvent>("render-widgets"),
  showToast: makeEvent<ShowToastEvent>("show-toast"),
  updateSettings: makeEvent<UpdateSettingsEvent>("update-settings"),
  updateWidgetCatalog: makeEvent<UpdateWidgetCatalogEvent>("update-widget-catalog"),
};

// =============================================================================
// Commands
// =============================================================================

export const commands = {
  core: {
    /**
     * Bundle widgets.
     * 
     * TODO(Charlie-XIAO)
     * 
     * ### Parameters
     * 
     * - `ids`: If provided, only bundle the widgets with the specified IDs that
     * exist in the widget catalog. If `None`, bundle all widgets in the catalog.
     * 
     * ### Errors
     * 
     * - TODO(Charlie-XIAO)
     */
    bundleWidgets: (
      ids: string[] | null,
    ) => invoke<null>("plugin:deskulpt-core|bundle_widgets", {
      ids,
    }),

    /**
     * Call a plugin command (ðŸš§ TODO ðŸš§).
     * 
     * ### ðŸš§ TODO ðŸš§
     * 
     * The Deskulpt core should keep a state of the registered plugins and call the
     * plugins dynamically. Also, instead of invoking the plugins directly, the
     * Deskulpt core should not depend on any of the plugins and should use IPC to
     * communicate with the plugins.
     * 
     * Also, in order to simplify the engine API for the plugin (because it is
     * a temporary implementation), `app_handle` is using the default runtime but
     * it should be a generic `R: Runtime` parameter in the final implementation.
     */
    callPlugin: (
      plugin: string,
      command: string,
      id: string,
      payload: JsonValue | null,
    ) => invoke<JsonValue>("plugin:deskulpt-core|call_plugin", {
      plugin,
      command,
      id,
      payload,
    }),

    /**
     * Wrapper of
     * [`emit_on_render_ready`](InitialRenderStateExt::emit_on_render_ready).
     * 
     * ### Errors
     * 
     * - Failed to emit the [`RenderWidgetsEvent`] to the canvas.
     */
    emitOnRenderReady: (
      event: RenderWidgetsEvent,
    ) => invoke<null>("plugin:deskulpt-core|emit_on_render_ready", {
      event,
    }),

    /**
     * Exit the application with cleanup.
     * 
     * This command never returns an error; in other words it will always exit the
     * application in the end. Prior to exiting, it will try to dump the settings
     * for persistence, but failure to do so will not prevent exiting.
     */
    exitApp: (
      settings: Settings,
    ) => invoke<void>("plugin:deskulpt-core|exit_app", {
      settings,
    }),

    /**
     * Open the widgets directory or a specific widget directory.
     * 
     * If the widget ID is provided, a specific widget directory will be opened.
     * Otherwise, the widgets directory will be opened.
     * 
     * ### Errors
     * 
     * - Widget ID is provided but does not exist in the collection.
     * - Failed to access the widgets directory.
     * - Error opening the directory.
     */
    openWidget: (
      id: string | null,
    ) => invoke<null>("plugin:deskulpt-core|open_widget", {
      id,
    }),

    /**
     * Rescan the widgets directory to discover widgets.
     * 
     * This command will update the widget catalog with the newly discovered
     * widgets and emit an event to notify the frontend of the updated catalog. It
     * also implicitly triggers the bundling of all widgets in the updated catalog,
     * see the [`bundle_widgets`] command.
     * 
     * ### Errors
     * 
     * - Error accessing the widgets directory.
     * - Error loading the new widget catalog from the widgets directory.
     * - Error emitting the event to notify the frontend of the updated catalog.
     * - Error bundling the widgets.
     */
    rescanWidgets: () => invoke<null>("plugin:deskulpt-core|rescan_widgets"),

    /**
     * Wrapper of [`set_render_ready`](InitialRenderStateExt::set_render_ready).
     * 
     * ### Errors
     * 
     * - Failed to emit the
     * [`RenderWidgetsEvent`](crate::events::RenderWidgetsEvent) to the canvas.
     */
    setRenderReady: () => invoke<null>("plugin:deskulpt-core|set_render_ready"),

    /**
     * Update the settings.
     * 
     * This command updates the settings state in the backend. If an update has
     * side effects, they will be applied prior to the update being committed. See
     * [`SettingsStateExt`] for more information.
     * 
     * ### Errors
     * 
     * - Failed to apply the side effects, if any.
     */
    updateSettings: (
      patch: SettingsPatch,
    ) => invoke<null>("plugin:deskulpt-core|update_settings", {
      patch,
    }),
  },
};
