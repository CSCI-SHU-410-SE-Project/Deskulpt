//! Internals of Deskulpt persistence-related macros.

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, parse_str, Data, DeriveInput, Expr, Fields, Ident, Lit, Meta, Type};

/// Token stream processor for the `#[derive(Persisted)]` macro.
pub fn proc_derive_persisted(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let original_name = &input.ident;
    let persisted_name = Ident::new(&format!("{}Persisted", original_name), original_name.span());

    let fields = match &input.data {
        Data::Struct(data_struct) => match &data_struct.fields {
            Fields::Named(fields_named) => &fields_named.named,
            _ => panic!("Persisted can only be derived for structs with named fields"),
        },
        _ => panic!("Persisted can only be derived for structs"),
    };

    let mut persisted_fields = Vec::new();
    let mut from_assignments = Vec::new();

    for field in fields {
        let field_name = field.ident.as_ref().unwrap();
        let field_type = &field.ty;

        // Parse field attributes
        let mut persisted_type = None;
        let mut default_fn = None;
        for attr in &field.attrs {
            if attr.path().is_ident("persisted") {
                match &attr.meta {
                    Meta::List(_) => {
                        attr.parse_nested_meta(|meta| {
                            if meta.path.is_ident("type") {
                                let value = meta.value()?;
                                if let Expr::Lit(expr_lit) = value.parse()? {
                                    if let Lit::Str(lit_str) = expr_lit.lit {
                                        persisted_type = Some(lit_str.value());
                                    }
                                }
                                Ok(())
                            } else if meta.path.is_ident("default") {
                                let value = meta.value()?;
                                if let Expr::Lit(expr_lit) = value.parse()? {
                                    if let Lit::Str(lit_str) = expr_lit.lit {
                                        default_fn = Some(lit_str.value());
                                    }
                                }
                                Ok(())
                            } else {
                                Err(meta.error("Unsupported #[persisted(...)] attribute"))
                            }
                        })
                        .expect("Failed to parse #[persisted(...)] attribute");
                    },
                    _ => panic!("Invalid #[persisted(...)] attribute format"),
                }
            }
        }

        let persisted_field_type = if let Some(ref persisted_type) = persisted_type {
            parse_str::<Type>(persisted_type)
                .unwrap_or_else(|_| panic!("Failed to parse persisted type: {persisted_type}"))
        } else {
            field_type.clone()
        };

        let serde_attr = if let Some(default_fn) = default_fn {
            quote! { #[serde(default = #default_fn)] }
        } else {
            quote! { #[serde(default)] }
        };

        persisted_fields.push(quote! {
            #[doc = concat!("[`", stringify!(#original_name), "::", stringify!(#field_name), "`]")]
            #serde_attr
            #field_name: #persisted_field_type
        });

        let assignment = if persisted_type.is_some() {
            quote! { #field_name: crate::settings::FromPersisted::from_persisted(persisted.#field_name) }
        } else {
            quote! { #field_name: persisted.#field_name }
        };
        from_assignments.push(assignment);
    }

    let expanded = quote! {
        #[doc = concat!("Persisted [`", stringify!(#original_name), "`].")]
        #[doc = ""]
        #[doc = "Generated by [`deskulpt_macros::Persisted`]."]
        #[derive(Default, ::serde::Deserialize)]
        struct #persisted_name {
            #(#persisted_fields,)*
        }

        impl From<#persisted_name> for #original_name {
            fn from(persisted: #persisted_name) -> Self {
                Self {
                    #(#from_assignments,)*
                }
            }
        }

        impl crate::settings::FromPersisted<#persisted_name> for #original_name {
            fn from_persisted(value: #persisted_name) -> Self {
                value.into()
            }
        }
    };
    TokenStream::from(expanded)
}
