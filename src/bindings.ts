/*! Auto-generated by deskulpt-specta. DO NOT EDIT! */

import { invoke } from "@tauri-apps/api/core";
import * as tauriEvent from "@tauri-apps/api/event";

// =============================================================================
// Types
// =============================================================================

/**
 * Application-wide settings.
 */
export type AppSettings = { 
/**
 * The application theme.
 */
theme: Theme; 
/**
 * The keyboard shortcuts.
 */
shortcuts: Partial<{ [key in ShortcutKey]: string }> }

/**
 * Deskulpt window enum.
 */
export type DeskulptWindow = 
/**
 * The manager window.
 */
"manager" | 
/**
 * The canvas window.
 */
"canvas"

export type InvalidWidget = { 
/**
 * The directory name of the widget.
 */
dir: string; 
/**
 * The error message.
 */
error: string }

export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }

/**
 * Event for removing widgets.
 * 
 * This event is emitted from the manager window to the canvas window when
 * widgets need to be removed.
 */
export type RemoveWidgetsEvent = 
/**
 * The list of widget IDs to be removed.
 */
string[]

/**
 * Event for re-rendering widgets.
 * 
 * This event is mainly emitted from the manager window to the canvas window
 * when settings or code of a widget needs to be re-rendered. It may also be
 * emitted from the backend to the canvas window for the initial render.
 */
export type RenderWidgetsEvent = 
/**
 * The list of widgets to be re-rendered.
 */
RenderWidgetsEventInner[]

/**
 * Inner structure for [`RenderWidgetsEvent`].
 */
export type RenderWidgetsEventInner = { 
/**
 * The ID of the widget being re-rendered.
 */
id: string; 
/**
 * If provided, update the settings of the widget.
 */
settings?: WidgetSettings; 
/**
 * If provided, update the code of the widget.
 */
code?: string }

/**
 * Full settings of the Deskulpt application.
 */
export type Settings = { 
/**
 * Application-wide settings.
 */
app: AppSettings; 
/**
 * The mapping from widget IDs to their respective settings.
 */
widgets: { [key in string]: WidgetSettings } }

/**
 * Message for updating settings.
 */
export type SettingsUpdate = 
/**
 * Update the theme.
 */
{ theme: Theme } | 
/**
 * Update a keyboard shortcut.
 * 
 * The first element is the shortcut key, and the second element is the new
 * shortcut value. `None` means to remove the shortcut.
 */
{ shortcut: [ShortcutKey, string | null] } | 
/**
 * Update the settings of a widget.
 * 
 * The first element is the widget ID, and the second element is the new
 * widget settings. If the widget ID does not exist, this is an error.
 */
{ widget: [string, WidgetSettingsUpdate] }

/**
 * Types of keyboard shortcuts in the application.
 */
export type ShortcutKey = 
/**
 * For toggling canvas interaction mode.
 */
"toggleCanvasImode" | 
/**
 * For opening the manager window.
 */
"openManager"

/**
 * Event for showing a toast notification.
 * 
 * This event is emitted from the backend to the canvas window when a toast
 * notification needs to be displayed.
 */
export type ShowToastEvent = 
/**
 * Show a [success](https://sonner.emilkowal.ski/toast#success) toast.
 */
{ type: "success"; content: string } | 
/**
 * Show an [error](https://sonner.emilkowal.ski/toast#error) toast.
 */
{ type: "error"; content: string }

/**
 * Light/dark theme of the application.
 */
export type Theme = "light" | "dark"

/**
 * Event for updating settings.
 * 
 * This event is emitted from the backend to the canvas and manager windows
 * when settings are updated.
 */
export type UpdateSettingsEvent = 
/**
 * The updated settings.
 */
Settings

export type ValidWidget = 
/**
 * The required `deskulpt.conf.json` configuration.
 */
({ 
/**
 * The name of the widget.
 * 
 * This is purely used for display purposes. It does not need to be related
 * to the widget directory name, and it does not need to be unique.
 */
name: string; 
/**
 * The entry point of the widget.
 * 
 * This is the path to the file that exports the widget component. The path
 * should be relative to the widget directory.
 */
entry: string }) & 
/**
 * The optional `package.json` configuration.
 */
({ dependencies?: { [key in string]: string } }) & { 
/**
 * The directory name of the widget.
 */
dir: string }

export type Widget = 
/**
 * A valid widget.
 */
({ type: "valid" } & ValidWidget) | 
/**
 * An invalid widget.
 */
({ type: "invalid" } & InvalidWidget)

/**
 * Per-widget settings.
 * 
 * Different from widget configurations, these are independent of the widget
 * configuration files and are managed internally by the application.
 */
export type WidgetSettings = { 
/**
 * The leftmost x-coordinate in pixels.
 */
x: number; 
/**
 * The topmost y-coordinate in pixels.
 */
y: number; 
/**
 * The opacity in percentage.
 */
opacity: number }

/**
 * Message for updating widget settings.
 */
export type WidgetSettingsUpdate = { 
/**
 * [`WidgetSettings::x`](crate::settings::WidgetSettings::x)
 */
x?: number; 
/**
 * [`WidgetSettings::y`](crate::settings::WidgetSettings::y)
 */
y?: number; 
/**
 * [`WidgetSettings::opacity`](crate::settings::WidgetSettings::opacity)
 */
opacity?: number }

// =============================================================================
// Events
// =============================================================================

function makeEvent<T>(name: string) {
  return {
    /** Listen for the event. */
    listen: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.listen(name, cb, options),
    /** Listen once for the event. */
    once: (cb: tauriEvent.EventCallback<T>, options?: tauriEvent.Options) =>
      tauriEvent.once(name, cb, options),
    /** Emit the event to all targets. */
    emit: (payload: T) => tauriEvent.emit(name, payload),
    /** Emit the event to a specific Deskulpt window. */
    emitTo: (window: DeskulptWindow, payload: T) =>
      tauriEvent.emitTo(window, name, payload),
  };
}

export const events = {
  removeWidgetsEvent: makeEvent<RemoveWidgetsEvent>("remove-widgets-event"),
  renderWidgetsEvent: makeEvent<RenderWidgetsEvent>("render-widgets-event"),
  showToastEvent: makeEvent<ShowToastEvent>("show-toast-event"),
  updateSettingsEvent: makeEvent<UpdateSettingsEvent>("update-settings-event"),
};

// =============================================================================
// Commands
// =============================================================================

export const commands = {
  /**
   * Bundle a widget.
   * 
   * ### Errors
   * 
   * - Failed to access the widgets directory.
   * - Widget ID does not exist in the configuration map.
   * - Widget has a configuration error.
   * - Error bundling the widget.
   */
  bundleWidget: (payload: {
    id: string,
    baseUrl: string,
    apisBlobUrl: string,
  }) => invoke<string>("bundle_widget", payload),

  /**
   * Call a plugin command (ðŸš§ TODO ðŸš§).
   * 
   * ### ðŸš§ TODO ðŸš§
   * 
   * The Deskulpt core should keep a state of the registered plugins and call the
   * plugins dynamically. Also, instead of invoking the plugins directly, the
   * Deskulpt core should not depend on any of the plugins and should use IPC to
   * communicate with the plugins.
   * 
   * Also, in order to simplify the engine API for the plugin (because it is
   * a temporary implementation), `app_handle` is using the default runtime but
   * it should be a generic `R: Runtime` parameter in the final implementation.
   */
  callPlugin: (payload: {
    plugin: string,
    command: string,
    id: string,
    payload: JsonValue | null,
  }) => invoke<JsonValue>("call_plugin", payload),

  /**
   * Wrapper of
   * [`emit_on_render_ready`](InitialRenderStateExt::emit_on_render_ready).
   * 
   * ### Errors
   * 
   * - Failed to emit the [`RenderWidgetsEvent`] to the canvas.
   */
  emitOnRenderReady: (payload: {
    event: RenderWidgetsEvent,
  }) => invoke<null>("emit_on_render_ready", payload),

  /**
   * Open the widgets directory or a specific widget directory.
   * 
   * If the widget ID is provided, a specific widget directory will be opened.
   * Otherwise, the widgets directory will be opened.
   * 
   * ### Errors
   * 
   * - Widget ID is provided but does not exist in the collection.
   * - Failed to access the widgets directory.
   * - Error opening the directory.
   */
  openWidget: (payload: {
    id: string | null,
  }) => invoke<null>("open_widget", payload),

  /**
   * Rescan the widgets directory and update the widget configuration map.
   * 
   * This will update the widget configuration map state and return the updated
   * configuration map as well.
   * 
   * ### Errors
   * 
   * - Failed to access the widgets directory.
   * - Error traversing the widgets directory.
   * - Error inferring widget ID from the directory entry.
   */
  rescanWidgets: () => invoke<{ [key in string]: Widget }>("rescan_widgets"),

  /**
   * Wrapper of [`set_render_ready`](InitialRenderStateExt::set_render_ready).
   * 
   * ### Errors
   * 
   * - Failed to emit the
   * [`RenderWidgetsEvent`](crate::events::RenderWidgetsEvent) to the canvas.
   */
  setRenderReady: () => invoke<null>("set_render_ready"),

  /**
   * Update the settings.
   * 
   * This command updates the settings state in the backend. If an update has
   * side effects, they will be applied prior to the update being committed. See
   * [`SettingsStateExt`] for more information.
   * 
   * ### Errors
   * 
   * - Failed to apply the side effects, if any.
   */
  updateSettings: (payload: {
    update: SettingsUpdate,
  }) => invoke<null>("update_settings", payload),
};
